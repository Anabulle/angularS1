<!DOCTYPE html>
<html>
<head>
<title>chap11_template_driven_forms.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="template-driven-forms">Template Driven Forms</h1>
<p>Vous avez deux types de formulaires avec Angular :</p>
<ul>
<li>Template driven Forms : création dans le template du formulaire. Quand
Angular parcourt le template et qu’il rencontre la balise form il créera
l’objet correspondant exploitable dans le TypeScript.</li>
<li>Reactive Form : création dynamique dans le TypeScript, elle offre plus de
possibilité.</li>
</ul>
<h2 id="template-driven-form">Template Driven form</h2>
<p>Nous allons développer un petit moteur de recherche dans notre application.</p>
<p>Dans le template, dans la balise input vous devez mettre ngModel et un attribut
name sur chaque input pour justement câbler cela. Ainsi Angular fera le lien
entre le template et le TypeScript.</p>
<p>La directive ngModel permet de définir et de contrôler un champ du formulaire
dans Angular.</p>
<p>Un simple attribut « name » pour sa part définit une clé/valeur qu’Angular
exploitera pour récupérer la valeur de tel ou tel champ.</p>
<p>Il faudra également définir l’événement (ngSubmit) : une méthode dans le
TypeScript permettra de récupérer l’objet formulaire du template dans le code
TypeScript.</p>
<p>Il faudra définir une référence locale pour accéder au formulaire dans le code
HTML.</p>
<h2 id="pr%C3%A9paration">Préparation</h2>
<p>Importez le module FormsModule (template driven forms), dans le fichier
app.module.ts :</p>
<pre class="hljs"><code><div>import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';


import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { PastriesComponent } from './pastries/pastries.component';
import { PastrieDetailsComponent } from './pastrie-details/pastrie-details.component';

@NgModule({
  declarations: [
    AppComponent,
    PastriesComponent,
    PastrieDetailsComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    FormsModule // importez le module
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
</div></code></pre>
<h2 id="exercice-16-mise-en-place">Exercice 16 (mise en place)</h2>
<p>Créez le component search, puis placez le sélecteur de ce component dans le
template du component PastriesComponent. Vous retirerez le HTML du formulaire de recherche (si vous l'aviez inclus)
dans la navigation principale (template des Sources du chap6 app.component.html) et
vous placerez l'appel du SearchComponent dans le template pastries.component.html, ce sera plus simple par la suite pour afficher
les résultats de la recherche dans le component PastriesComponent.</p>
<h2 id="exercice-17-formulaireapplication">Exercice 17 (formulaire/application)</h2>
<p>Nous allons maintenant travailler dans le component SearchComponent.</p>
<p>Voici le code que vous devez écrire :</p>
<pre class="hljs"><code><div>&lt;!--
Méthode onSubmit à définir dans le TypeScript.
Vous devez également définir une référence locale #formSearch.
Ainsi que les directives ngModel pour lier un champ à son nom (data-binding)
--&gt;
&lt;form class=&quot;form-inline my-2 my-lg-0 d-inline-flex&quot;
      (ngSubmit)=&quot;onSubmit(formSearch)&quot;
      #formSearch=&quot;ngForm&quot;
&gt;
  &lt;input name=&quot;word&quot;
         ngModel required
         class=&quot;form-control mr-sm-2&quot;
         type=&quot;search&quot;
         placeholder=&quot;Search&quot;
         aria-label=&quot;Search&quot;
  &gt;
  &lt;!-- Directive disabled pour désactiver le formulaire si il n'est pas valide --&gt;
  &lt;button
          [disabled]=&quot;formSearch.invalid&quot;
          class=&quot;btn btn-outline-success my-2 my-sm-0 m-4&quot;
          type=&quot;submit&quot;
  &gt;
    Search
  &lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<h2 id="ngmodel">ngModel</h2>
<p>Angular parcourt le template, et lorsqu’il trouve la balise <strong>form</strong> il crée cet objet,
utilisable dans le TypeScript. Il faut préciser à Angular quel champ est un
“controls”, un champ à enregistrer afin de pouvoir récupérer sa valeur dans le
TypeScript. Définissez un <strong>name</strong> et ajoutez la directive <strong>ngModel</strong> dans la balise
input. Cette relation est du one-way data-binding (unidirectionnelle) elle est
suffisante pour récupérer les valeurs d’un formulaire lors de sa soumission.</p>
<p>Il existe une autre syntaxe pour ngModel qui relie le name au TypeScript dans
une relation two-way data-binding :</p>
<pre class="hljs"><code><div>[(ngModel)]=&quot;name&quot;
</div></code></pre>
<p><strong>Notez que l’attribut required dans le HTML empêchera une soumission sans contenu.</strong></p>
<p>Il faudra également importer NgForm, le type de l’objet form récupéré par
Angular dans la méthode onSubmit (méthode appelée à la soumission grâce à
l’événement ngSubmit ) :</p>
<pre class="hljs"><code><div>import { Component, OnInit } from '@angular/core';
import { NgForm } from '@angular/forms'; // template-driven

import { PastrieService } from '../pastrie.service';
import { Pastrie } from '../pastrie';

@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.scss']
})
export class SearchComponent implements OnInit {
    
  constructor() { }
  
  ngOnInit() {}
  
  onSubmit(form: NgForm): void {
  // récupération des données du formulaire
    console.log(form);
  }
}
</div></code></pre>
<p>Pour récupérer les valeurs d’un formulaire vous utiliserez la méthode suivante
form.value[NameAttribute]. Ici on a qu’une seule paire de clé/valeur, mais vous
devez fonctionner comme cela pour tous les champs d’un formulaire (ngModel +
name) pour le template driven forms :</p>
<pre class="hljs"><code><div>onSubmit(form: NgForm): void {
    console.log(form.value['word']); // récupération d'une valeur spécifique
}
</div></code></pre>
<h2 id="exercice-18">Exercice 18</h2>
<p>Vous allez maintenant créer une méthode dans le service PastrieService, afin
d’effectuer une recherche sur les noms des pâtisseries à partir d’un mot saisi dans le
formulaire. Vous appellerez cette méthode search dans votre service.</p>
<p>Testez votre méthode avec un simple console.log dans le component SearchComponent dans un premier temps.</p>
<p><em>Indications : pensez à faire de l’injection de dépendance pour votre service
PastrieService.</em></p>
<h2 id="exercice-19">Exercice 19</h2>
<p>Mettez en place maintenant la communication entre l’enfant et le parent et
essayez d’afficher le résultat de votre recherche dans la page principale : pastries.component.html</p>
<p><em>Indications : revoyez ce que nous avons déjà réalisé à ce sujet : ici l’enfant doit
émettre le résultat de la recherche au parent.</em></p>
<h2 id="exercice-20">Exercice 20</h2>
<p>En utilisant l’attribut directive ngModelChange, qui permet de détecter les
changements du modèle ngModel et la syntaxe banana in a box [(ngModel)]
pour lier la propriété word, faites en sorte de pouvoir effectuer une recherchant mettant à jour les
pâtisseries sur la page principale (PastriesComponent).</p>
<p>La syntaxe <strong>banana in a box</strong> permet de lier la propriété “word” dans les deux
sens, vue et TypeScript : data-binding two-way.</p>
<p><em>Indications : utilisez un EventEmitter pour signifier au Component
PastriesComponent qu’il faut mettre à jour les pâtisseries.</em></p>
<pre class="hljs"><code><div>&lt;input name=&quot;word&quot; [(ngModel)]=&quot;word&quot; (ngModelChange)=&quot;onChangeEmit($event)&quot; /&gt;
</div></code></pre>

</body>
</html>
